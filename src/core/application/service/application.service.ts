import { Injectable, Logger } from '@nestjs/common';
import IApplicationRepository from '../repository/application.repository.interface';
import IApplicationKeyRepository from '../repository/application-key.repository.interface';
import { Application, ApplicationKey } from '@prisma/client';
import { JwtService } from '@nestjs/jwt';
import { PaginationResult } from 'src/shared/dto';
import { mapToPaginationData } from 'src/shared/mapper';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
import {
  InvalidApplicationException,
  UnAuthorizedKeyActionException,
} from '../exception';

type CreateApplicationParam = {
  name: string;
  description?: string;
  routeName?: string;
  ownerId: string;
};

type CreateApplicationKeyParam = {
  name: string;
  description?: string;
  applicationId: string;
  ownerId: string;
};

type CreateApplicationResult = {
  id: string;
  appName: string;
  description?: string;
  appUrl: string;
  createdAt: Date;
  defaultKey: {
    id: string;
    name: string;
    description?: string;
    createdAt: Date;
    credential: string;
  };
};

type GetApplicationsParam = {
  ownerId: string;
  page: number;
  size: number;
};

type GetApplicationKeysByAppIdParam = {
  appId: string;
  ownerId: string;
};

type DisableApplicationKeyParam = {
  appId: string;
  keyId: string;
  ownerId: string;
};

@Injectable()
export default class ApplicationService {
  private readonly logger = new Logger(ApplicationService.name);

  constructor(
    private readonly applicationRepository: IApplicationRepository,
    private readonly applicationKeyRepository: IApplicationKeyRepository,
    private readonly jwtService: JwtService,
  ) {}

  // for create new application
  async createApplication(
    param: CreateApplicationParam,
  ): Promise<CreateApplicationResult> {
    try {
      this.logger.log(
        'Started executing createApplication() with param ',
        JSON.stringify(param, null, 2),
      );
      // if route name is not included, will create from name
      const routeName =
        param.routeName || param.name.toLowerCase().replaceAll(' ', '-');
      // save app to database
      const savedApplication = await this.applicationRepository.save({
        ...param,
        routeName,
      });
      // create app's default key and store to database
      const savedApplicationKey = await this.createApplicationKey({
        applicationId: savedApplication.id,
        name: `${param.name.toUpperCase().replaceAll('', '')}'s Key`,
        description: 'Auto-generated by Cloud-Logger!',
        ownerId: param.ownerId,
      });
      return this.mapToCreateApplicationResult(
        savedApplication,
        savedApplicationKey,
      );
    } catch (e) {
      this.logger.error('Failed executing createApplication() ', e);
      throw e;
    } finally {
      this.logger.log('Finished executing createApplication() ');
    }
  }

  mapToCreateApplicationResult(
    app: Application,
    key: ApplicationKey,
  ): CreateApplicationResult {
    return {
      id: app.id,
      appName: app.name,
      description: app.description,
      appUrl: app.routeName,
      createdAt: app.createdAt,
      defaultKey: {
        id: key.id,
        name: key.name,
        description: key.description,
        createdAt: key.createdAt,
        credential: key.credential,
      },
    };
  }

  // for create application key
  async createApplicationKey(
    param: CreateApplicationKeyParam,
  ): Promise<ApplicationKey> {
    try {
      this.logger.log(
        'Started executing createApplicationKey() with param ',
        JSON.stringify(param, null, 2),
      );
      // check owner is real owner for app
      const savedApp = await this.applicationRepository.findById(
        param.applicationId,
      );
      if (!savedApp || savedApp.ownerId !== param.ownerId) {
        throw new UnAuthorizedKeyActionException();
      }
      // generate credential
      const credential = await this.jwtService.signAsync({
        appId: param.applicationId,
        keyName: param.name,
      });
      // save to database
      const result = await this.applicationKeyRepository.save({
        ...param,
        credential,
      });
      return result;
    } catch (e) {
      this.logger.error('Failed executing createApplicationKey() ', e);
      if (e instanceof PrismaClientKnownRequestError) {
        if (e.code === 'P2003') {
          throw new InvalidApplicationException();
        }
      }
      throw e;
    } finally {
      this.logger.log('Finished executing createApplicationKey() ');
    }
  }

  // for getting appliction list by ownerId
  async getApplicationsByOwnerId(
    param: GetApplicationsParam,
  ): Promise<PaginationResult<Application>> {
    try {
      this.logger.log('Started executing getApplicationsByOwnerId() ');
      const { page, size, ownerId } = param;
      const totalData =
        await this.applicationRepository.countByOwnerId(ownerId);
      const contents = await this.applicationRepository.findByOwnerId({
        ownerId: ownerId,
        page: page,
        size: size,
      });
      return mapToPaginationData({
        contents,
        totalData,
        page,
        size,
      });
    } catch (e) {
      this.logger.error('Failed executing getApplicationsByOwnerId() ', e);
      throw e;
    } finally {
      this.logger.log('Finished executing getApplicationsByOwnerId() ');
    }
  }

  // for getting application keys by app id
  async getApplicationKeysByAppId(param: GetApplicationKeysByAppIdParam) {
    try {
      this.logger.log(
        'Started executing getApplicationKeysByAppId() with param ',
        JSON.stringify(param, null, 2),
      );
      const result = await this.applicationKeyRepository.findByAppId(param);
      return result;
    } catch (e) {
      this.logger.error('Failed executing getApplicationKeysByAppId() ', e);
      throw e;
    } finally {
      this.logger.log('Finished executing getApplicationKeysByAppId() ');
    }
  }

  // for disabling application key
  async disableApplicationKey(param: DisableApplicationKeyParam) {
    try {
      this.logger.log(
        'Started executing disableApplicationKey() with param ',
        JSON.stringify(param, null, 2),
      );
      return await this.applicationKeyRepository.disableKeyById(param);
    } catch (e) {
      this.logger.error('Failed executing disableApplicationKey() ');
      throw e;
    } finally {
      this.logger.log('Finished executing disableApplicationKey() ');
    }
  }
}
