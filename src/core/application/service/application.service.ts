import { Injectable, Logger } from '@nestjs/common';
import IApplicationRepository from '../repository/application.repository.interface';
import IApplicationKeyRepository from '../repository/application-key.repository.interface';
import {
  Application,
  ApplicationKey,
  ApplicationLog,
  LogType,
} from '@prisma/client';
import { JwtService } from '@nestjs/jwt';
import { PaginationResult } from 'src/shared/dto';
import { mapToPaginationData } from 'src/shared/mapper';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
import {
  InvalidApplicationException,
  UnAuthorizedKeyActionException,
} from '../exception';
import IApplicationLogRepository from '../repository/application-log.repository.interface';

type CreateApplicationParam = {
  name: string;
  description?: string;
  routeName?: string;
  ownerId: string;
};

type CreateApplicationKeyParam = {
  name: string;
  description?: string;
  applicationId: string;
  ownerId: string;
};

type CreateApplicationResult = {
  id: string;
  appName: string;
  description?: string;
  appUrl: string;
  createdAt: Date;
  defaultKey: {
    id: string;
    name: string;
    description?: string;
    createdAt: Date;
    credential: string;
  };
};

type GetApplicationsParam = {
  ownerId: string;
  page: number;
  size: number;
};

type GetApplicationKeysByAppIdParam = {
  appId: string;
  ownerId: string;
};

type DisableApplicationKeyParam = {
  appId: string;
  keyId: string;
  ownerId: string;
};

type SaveApplicationLogParam = {
  logType: LogType;
  message: string;
  detailContent: string;
  metadata: string;
  applicationId: string;
  credential: string;
  credentialId: string;
};

type GetApplicationLogsParam = {
  appId: string;
  page: number;
  size: number;
  ownerId: string;
};

@Injectable()
export default class ApplicationService {
  private readonly logger = new Logger(ApplicationService.name);

  constructor(
    private readonly applicationRepository: IApplicationRepository,
    private readonly applicationKeyRepository: IApplicationKeyRepository,
    private readonly jwtService: JwtService,
    private readonly applicationLogRepository: IApplicationLogRepository,
  ) {}

  // for create new application
  async createApplication(
    param: CreateApplicationParam,
  ): Promise<CreateApplicationResult> {
    try {
      this.logger.log(
        'Started executing createApplication() with param ',
        JSON.stringify(param, null, 2),
      );
      // if route name is not included, will create from name
      const routeName =
        param.routeName || param.name.toLowerCase().replaceAll(' ', '-');
      // save app to database
      const savedApplication = await this.applicationRepository.save({
        ...param,
        routeName,
      });
      // create app's default key and store to database
      const savedApplicationKey = await this.createApplicationKey({
        applicationId: savedApplication.id,
        name: `${param.name.toUpperCase().replaceAll('', '')}'s Key`,
        description: 'Auto-generated by Cloud-Logger!',
        ownerId: param.ownerId,
      });
      return this.mapToCreateApplicationResult(
        savedApplication,
        savedApplicationKey,
      );
    } catch (e) {
      this.logger.error('Failed executing createApplication() ', e);
      throw e;
    } finally {
      this.logger.log('Finished executing createApplication() ');
    }
  }

  mapToCreateApplicationResult(
    app: Application,
    key: ApplicationKey,
  ): CreateApplicationResult {
    return {
      id: app.id,
      appName: app.name,
      description: app.description,
      appUrl: app.routeName,
      createdAt: app.createdAt,
      defaultKey: {
        id: key.id,
        name: key.name,
        description: key.description,
        createdAt: key.createdAt,
        credential: key.credential,
      },
    };
  }

  // for create application key
  async createApplicationKey(
    param: CreateApplicationKeyParam,
  ): Promise<ApplicationKey> {
    try {
      this.logger.log(
        'Started executing createApplicationKey() with param ',
        JSON.stringify(param, null, 2),
      );
      // check owner is real owner for app
      const savedApp = await this.applicationRepository.findById(
        param.applicationId,
      );
      if (!savedApp || savedApp.ownerId !== param.ownerId) {
        throw new UnAuthorizedKeyActionException();
      }
      // generate credential
      const credential = await this.jwtService.signAsync({
        appId: param.applicationId,
        keyName: param.name,
      });
      // save to database
      const result = await this.applicationKeyRepository.save({
        ...param,
        credential,
      });
      return result;
    } catch (e) {
      this.logger.error('Failed executing createApplicationKey() ', e);
      if (e instanceof PrismaClientKnownRequestError) {
        if (e.code === 'P2003') {
          throw new InvalidApplicationException();
        }
      }
      throw e;
    } finally {
      this.logger.log('Finished executing createApplicationKey() ');
    }
  }

  // for getting appliction list by ownerId
  async getApplicationsByOwnerId(
    param: GetApplicationsParam,
  ): Promise<PaginationResult<Application>> {
    try {
      this.logger.log('Started executing getApplicationsByOwnerId() ');
      const { page, size, ownerId } = param;
      const totalData =
        await this.applicationRepository.countByOwnerId(ownerId);
      const contents = await this.applicationRepository.findByOwnerId({
        ownerId: ownerId,
        page: page,
        size: size,
      });
      return mapToPaginationData({
        contents,
        totalData,
        page,
        size,
      });
    } catch (e) {
      this.logger.error('Failed executing getApplicationsByOwnerId() ', e);
      throw e;
    } finally {
      this.logger.log('Finished executing getApplicationsByOwnerId() ');
    }
  }

  // for getting application keys by app id
  async getApplicationKeysByAppId(param: GetApplicationKeysByAppIdParam) {
    try {
      this.logger.log(
        'Started executing getApplicationKeysByAppId() with param ',
        JSON.stringify(param, null, 2),
      );
      const result = await this.applicationKeyRepository.findByAppId(param);
      return result;
    } catch (e) {
      this.logger.error('Failed executing getApplicationKeysByAppId() ', e);
      throw e;
    } finally {
      this.logger.log('Finished executing getApplicationKeysByAppId() ');
    }
  }

  // for disabling application key
  async disableApplicationKey(param: DisableApplicationKeyParam) {
    try {
      this.logger.log(
        'Started executing disableApplicationKey() with param ',
        JSON.stringify(param, null, 2),
      );
      return await this.applicationKeyRepository.disableKeyById(param);
    } catch (e) {
      this.logger.error('Failed executing disableApplicationKey() ');
      throw e;
    } finally {
      this.logger.log('Finished executing disableApplicationKey() ');
    }
  }

  // for saving application log
  async saveApplicationLog(
    param: SaveApplicationLogParam,
  ): Promise<ApplicationLog> {
    try {
      this.logger.log(
        'Started executing saveApplicationLog() with param ',
        JSON.stringify(param, null, 2),
      );

      // save to database
      const result = await this.applicationLogRepository.save({
        ...param,
        applicationKeyId: param.credentialId,
      });
      return result;
    } catch (e) {
      this.logger.error('Failed executing saveApplicationLog() ', e);
      throw e;
    } finally {
      this.logger.log('Finished executing saveApplicationLog() ');
    }
  }

  // for getting application instance by id
  async getApplicationById(id: string): Promise<Application | null> {
    try {
      this.logger.log('Started executing getApplicationById()');
      const result = await this.applicationRepository.findById(id);
      return result;
    } catch (e) {
      this.logger.error('Failed executing getApplicationById() ', e);
      throw e;
    } finally {
      this.logger.log('Finished executing getApplicationById() ');
    }
  }

  // for getting application key by id
  async getApplicationKeyById(keyId: string): Promise<ApplicationKey | null> {
    try {
      this.logger.log('Started executing getApplicationKeyById() ');
      const result = await this.applicationKeyRepository.findById(keyId);
      return result;
    } catch (e) {
      this.logger.error('Failed executing getApplicationKeyById()', e);
      throw e;
    } finally {
      this.logger.log('Finished executing getApplicationKeyById() ');
    }
  }

  // for getting application logs
  async getApplicationLogs(
    param: GetApplicationLogsParam,
  ): Promise<PaginationResult<ApplicationLog>> {
    try {
      this.logger.log('Started executing getApplicationLogs() ');
      const { appId, page, size, ownerId } = param;
      const totalCount = await this.applicationLogRepository.countByAppId({
        appId: param.appId,
        ownerId: param.ownerId,
      });
      const contents = await this.applicationLogRepository.findByAppId({
        appId,
        page,
        size,
        ownerId,
      });
      return mapToPaginationData({
        contents,
        page,
        size,
        totalData: totalCount,
      });
    } catch (e) {
      this.logger.error('Failed executing getApplicationLogs() ', e);
      throw e;
    } finally {
      this.logger.log('Finished executing getApplicationLogs() ');
    }
  }
}
